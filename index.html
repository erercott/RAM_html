<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>DoD Prototype HTML</title>
<style>
  body {
    background: #fff;
    display: flex;
    justify-content: center;
    align-items: start;
    height: 100vh;
    margin: 0;
  }
  canvas {
    background: #222;
    display: block;
    outline: none;
  }
</style>
</head>
<body>
<canvas id="gameCanvas" width="1226" height="733" tabindex="0"></canvas>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let ambientSound = new Audio('ambient.mp3');
ambientSound.loop = true;

let hitSound = new Audio('hit.mp3');
let chimeSound = new Audio('chime.mp3');

let clearedOrientations = [
  [false,false,false,false],
  [false,false,false,false],
  [false,false,false,false]
];

let combos = [
  {active:false, count:0},
  {active:false, count:0},
  {active:false, count:0}
];

canvas.focus();

const inset = 40;
const arenaHeight = 500;
const portraitWidth = 220;
const playerBoxWidth = 50;
const playerBoxHeight = 50;
const triangleMargin = 4;

let orientation = 0;
let triangleColor = 'red';
let flickerVisible = true;
let enemyOrbs = [];

let characterPortrait = new Image();
characterPortrait.src = 'portrait.png';

// --- Initialize orbs ---
function spawnOrbs(){
    enemyOrbs = [];
    const numOrbs = 1 + Math.floor(Math.random()*3);
    const colors = ['red','green','blue'];
    let orbColors = [];
	
	for(let i=0;i<numOrbs;i++){
		orbColors.push(colors[Math.floor(Math.random()*3)]);
	}
	
    const arenaW = canvas.width - inset*2 - portraitWidth - 20;
    const arenaX = inset;
    const arenaY = inset;
    const slotWidth = arenaW/numOrbs;

    for(let i=0;i<numOrbs;i++){
        let orbX = arenaX + i*slotWidth + slotWidth/2 - 25;
        let orbY = arenaY + arenaHeight/2 - 25;
        enemyOrbs.push({x:orbX, y:orbY, size:50, color:orbColors[i], orientation:Math.floor(Math.random()*4)});
    }
}

// --- Draw ---
function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    const arenaX = inset;
    const arenaY = inset;
    const arenaW = canvas.width - inset*2 - portraitWidth - 20;
    const arenaH = arenaHeight;

    ctx.strokeStyle='rgb(0,180,255)';
    ctx.lineWidth=5;
    ctx.strokeRect(arenaX,arenaY,arenaW,arenaH);

    // Player box
    const playerX = arenaX + arenaW/2 - playerBoxWidth/2;
    const playerY = arenaY + arenaH + 10;
    ctx.strokeStyle='black';
    ctx.lineWidth=1;
    ctx.strokeRect(playerX,playerY,playerBoxWidth,playerBoxHeight);

    // Triangle
    if(flickerVisible){
        const triSize = (playerBoxWidth/2)-triangleMargin;
        ctx.save();
        ctx.translate(playerX + playerBoxWidth/2, playerY + playerBoxHeight/2);
        ctx.rotate(orientation * Math.PI/2);
        ctx.fillStyle = triangleColor;
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.lineTo(-triSize,-triSize);
        ctx.lineTo(-triSize,triSize);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
    }

    // Character portrait
    if(characterPortrait.complete){
        const portraitX = canvas.width - portraitWidth - 20;
        const portraitY = arenaY;
        ctx.drawImage(characterPortrait, portraitX, portraitY, portraitWidth, arenaH);
        ctx.strokeStyle='black';
        ctx.lineWidth=2;
        ctx.strokeRect(portraitX,portraitY,portraitWidth,arenaH);
    }

    // Combos display
    const shapeSize = 20;
    const spacing = 20;
    const startX = canvas.width - portraitWidth - 20;
    const startY = arenaHeight + 40;

    ['red','green','blue'].forEach((color,i)=>{
        if(combos[i].active){
            const cx = startX + i*(shapeSize*2 + spacing) + shapeSize;
            const cy = startY + shapeSize;

            // Diamond
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(cx, cy-shapeSize);
            ctx.lineTo(cx-shapeSize, cy);
            ctx.lineTo(cx, cy+shapeSize);
            ctx.lineTo(cx+shapeSize, cy);
            ctx.closePath();
            ctx.fill();

            ctx.strokeStyle='black';
            ctx.lineWidth=2;
            ctx.stroke();

            ctx.fillStyle='white';
            ctx.font='14px Arial';
            const text = combos[i].count;
            const textWidth = ctx.measureText(text).width;
            ctx.fillText(text, cx - textWidth/2, cy + shapeSize + 16);
        }
    });

    // Enemy orbs
    enemyOrbs.forEach(orb=>{
        ctx.fillStyle = orb.color;
        ctx.beginPath();
        ctx.arc(orb.x + orb.size/2, orb.y + orb.size/2, orb.size/2,0,2*Math.PI);
        ctx.fill();

        const triSize=10;
        ctx.save();
        ctx.translate(orb.x + orb.size/2, orb.y + orb.size/2);
        ctx.rotate(orb.orientation*Math.PI/2);
        ctx.fillStyle='black';
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.lineTo(-triSize,-triSize);
        ctx.lineTo(-triSize,triSize);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
    });
}

// --- Flicker ---
function flicker(){
    flickerVisible = true;
    let elapsed = 0;
    const interval = setInterval(()=>{
        elapsed+=16;
        flickerVisible = Math.floor(elapsed/30)%2===0;
        if(elapsed>=500){
            flickerVisible=true;
            clearInterval(interval);
        }
    },16);
}

// --- Controls ---
canvas.addEventListener('keydown', e=>{
    ambientSound.play();
    switch(e.key){
        case 'ArrowRight': orientation=(orientation+1)%4; break;
        case 'ArrowLeft': orientation=(orientation+3)%4; break;
        case 'ArrowUp':
            triangleColor = triangleColor==='red'?'green':triangleColor==='green'?'blue':'red';
            break;
        case 'ArrowDown':
            let hit=false;

            enemyOrbs = enemyOrbs.filter(orb=>{
                if(orb.orientation===orientation && orb.color===triangleColor){
                    hit=true;
                    const colorIndex = triangleColor==='red'?0:triangleColor==='green'?1:2;
                    clearedOrientations[colorIndex][orientation]=true;

                    if(clearedOrientations[colorIndex].every(v=>v)){
                        combos[colorIndex].active=true;
                        combos[colorIndex].count++;
                        chimeSound.currentTime=0;
                        chimeSound.play();
                        clearedOrientations[colorIndex] = [false,false,false,false];
                    }
                    return false;
                }
                return true;
            });

            // Miss -> reset all progress & hide diamonds
            if(!hit){
                ['red','green','blue'].forEach((c,i)=>{
                    clearedOrientations[i] = [false,false,false,false];
                    combos[i].count = 0;
					combos[i].active = false; 
                });
            }

            if(hit) hitSound.play();
            flicker();

            if(enemyOrbs.length===0) spawnOrbs();
            break;
    }
    e.preventDefault();
});

// --- Main loop ---
spawnOrbs();
setInterval(draw,16);
</script>
</body>
</html>
